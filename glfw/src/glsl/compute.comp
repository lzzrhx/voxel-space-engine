#version 430 core

struct Camera {
    vec2 clip_r;
    vec2 clip_l;
    vec2 chunk_pos;
    float z;
    float tilt;
    // fog start
    // fog end
};

// In
layout (local_size_x = 10, local_size_y = 1, local_size_z = 1) in;

// Uniform
layout(rgba32f, binding = 0) uniform image2D texture_render;
uniform float width;
uniform uint height;
uniform sampler2D texture_terrain_color;
uniform sampler2D texture_terrain_height;
uniform Camera camera;
uniform float cam_clip;
uniform float terrain_size;
uniform float terrain_scale;

void draw_line(float x, float y_start, float y_end, float depth, vec3 color) {
    for (float y = y_start; y < y_end; y++) {
        imageStore(texture_render, ivec2(x, y), vec4(color, 1.0));
    }
}

void main() {
    float x = gl_GlobalInvocationID.x;
    vec2 delta = vec2((camera.clip_l.x + (camera.clip_r.x - camera.clip_l.x) / width * x) / cam_clip, (camera.clip_l.y + (camera.clip_r.y - camera.clip_l.y) / width * x) / cam_clip);
    vec2 pos = camera.chunk_pos;
    uint max_z = height;
    for (uint depth = 1; depth < uint(cam_clip); depth++) {
        pos += delta;
        ivec2 ipos = ivec2(pos);
        if (ipos.x < 0.0 || ipos.x > terrain_size || ipos.y < 0.0 || ipos.y > terrain_size) { return; }
        vec2 tex_coords = vec2(ipos.x / width, ipos.y / float(height));
        uint terrain_height = uint(texture(texture_terrain_height, tex_coords).r * 255.0);
        uint z = uint((camera.z - terrain_height) / float(depth) * terrain_scale + camera.tilt);
        //if (z < 0.0 || z > height) { return; }
        if (z < max_z) {
            vec3 color = texture(texture_terrain_color, tex_coords).rgb;
            //vec3 color = vec3(terrain_height);
            draw_line(x, z, max_z, depth, color);
            max_z = z;
            //imageStore(texture_render, ivec2(x, z), vec4(color, 1.0));
        }
            //vec3 color = texture(texture_terrain_color, tex_coords).rgb;
            //imageStore(texture_render, ivec2(x, z), vec4(color, 1.0));
        //ipos = ivec2(pos);
        //if (ipos.x < 0 || ipos.x > terrain_size-1 || ipos.y < 0 || ipos.y > terrain_size-1) { return; }
        //uint i = ipos.x + ipos.y * terrain_size;
        //uint y = depth;
        //vec3 color = vec3(ivec2(x, y).yxy) / width;
        //vec3 color = vec3(y / width);
        //vec3 color = texture(texture_terrain_color, vec2(x / width,y / height)).rgb;
        //if (tex_coords.x < 0.0 || tex_coords.x > 1.0) { color = vec3(1.0); }
    }
}
